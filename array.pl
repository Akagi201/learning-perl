#!/usr/bin/perl

# 列表 - 数组的形式
# (1, "a", 2.3, $a, $x + 1)
# 元素可以是任意类型, 变量, 表达式
# 空列表: ()
# 单元素列表: (2), 与值2不同.
# qw(1 $a str)
# qw用法同q, qq. ()可替换成其他符号<>
# 可以为值, 变量, 不用引号的字符串, 由空格分开.
# 作为逗号运算返回最右的元素. $a=(1,2) $a=2.

print "单元素列表: ";
@a=(2);
print @a;
$a=$a[0];
print $a;

# 范围表示的列表
# .. :范围运算符. 每次增1. 1..3
# (1,2,3,4,5,6) --> (1..6)元素从左边的值增加到右边的值.
# (1,2,3,4,5,6) --> (1, 2..5, 6) 部分使用范围.
# (3..3) --> (3) 首尾一样, 不能增.
# (2.4..5.3) --> (2.4, 3.4, 4.4)小数同样也增1, 到小于右边的值的小数.
# (4.5..1.6) --> () 左边值>右边值则为空.
# ("aa".."ad") --> ("aa", "ab", "ac", "ad")同样可用于字符串增加, 规则同字符串
# 自增. $month=('01'..'31').
# ($a,$a+3) --> 设$a=3则为(3,4,5,6)同样可用于变量表达式.

print "\n列表范围:";
@a=(4.5..1.6);
print "@a\n";

# 数组-列表的存储
# 形式
# 数组形式: @a=(1,2,3);
# 与$a是不同的变量.
# 初始为空()

# 元素形式: $a[0]
# 数组的元素为简单变量, 以$开头. 后面的变量名同数组名.
# 下标从0开始. []有时也称运算符.
# 负索引: 最后一个元素可以用$a[-1]表示, 倒数第二个为$a[-2].
# 列表也可以有下标: (1,2,3)[0]->1, 但是列表没有存储, 不能在下次使用.
# 在字符串中"$a[0]"为元素, "$a\[0]", "${a}[0]", "$\{a}[0]"均为字符串$a[0].

print "列表元素:";
$a=(1,2,3,4)[1];
print "$a\n";

# 数组的赋值
# 形式: 以下结果@a均为含元素1,2,3,4的数组.
# @a=(1,2,3,4); 标准的列表赋值.
# @b=(1,2,3,4), @a=@b; 数组复制.
# @b=(2,3), @a=(1,@b,4);
# @b=('a')*4; ==> @b=('a', 'a', 'a', 'a');
# @b=<>; 从标准输入(键盘)读出一行赋予元素, 最后用ctrl-d结束输入.
# 改变元素的值: $a[1]=3; @a=(1,3,3,4);
# 超出数组大小的元素: $a[5]=6; @a=(1,2,3,4,"",6)数组自动增长, 原来没有的元素值为NULL.
# 读不存在的元素为空: $x=$a[7];

# 数组的读取
# 单个元素读取: $a=$a[1];
# 多元素读取:
# 每个元素对应到变量:
@a=(1,2,3);
($x,$y,$z)=@a;
# $x=1, $y=2, $z=3;

# 多余的变量为空:
($a, $b, $c, $d) = @a;
# $a=1, $b=2, $c=3, $d="";

# 变量不足, 后续元素忽略:
($a,$b)=@a;
# $a=1, $b=2;

# 数组读取:
# $a=@a; $a为数组长度.
# ($a)=@a; 为读取第一元素.
# $a=(1,2,3); 返回最右的元素, $a=3; 
# $#a数组最后一个元素的索引. 加1即为长度. 但对$#a复制就改变了数组的长度.

# 数组的输出
# print @a, 元素相连. print "@a"; 元素间加空格.

print "列表赋值:";
$a=(1,2,3);
print "$a\n";

print "\$#a的应用:";
@a=(1,2,3);
print "@a";
print "数组长度为$#a+1\t";
$#a=1;
print "数组元素减少为@a\n";

# 数组片断
# 访问数组的部分元素. 不是单元素, 不是全部.
@a=(1,2,3,4,5);
# 读取
@sub=@a[0,1,3];
# print "\n@sub\n";
# @sub=(1,2,4);
# 赋值
@a[1,3]=("a", "b");
# @a=(1, "a", 3, "b", 5);

# 数组的元素列表可用列表的各种形式表示
# 范围:
@sub=@a[1..3];
#@sub=(2,3,4);
$x=1, $y=3;
@sub=@a[$x..$y];
#@sub=(2,3,4);

# 列表:
@b=(1,2,3);
@sub=@a[@b];
# @sub=(2,3,4);
($a, @b, $c) = (1,2,3,4,5);
# $a=1;
# @b=(2,3,4,5);
# $c="";

# 数组元素重叠:
# 交换
@a[1,2]=@a[2,1];
# @a=(2,1,3,4,5);

# 重叠
@a[1,2,3]=@a[3,2,4];
# @a=(1,4,3,5,5);

# 数组操作函数
# sort {代码块}或函数名 @array也可以(@array)
# 缺省是按照字符排序方式, 可省略代码块.
# $a, $b代表数组的元素, @_代表数组.

print "sort的使用:";
@a=(1,12,4,8,20);
print sort(@a);
print sort {$a<=>$b} (@a);

# reverse @a, 数组反序.
# chop @a, 每个元素截去最后一个字符.
# shift(@a)删除数组第一个元素, 返回删除的元素. 缺省对@ARGV数组.
# unshift(@a, $a): 在数组开头增加元素, 返回新数组长度.
# push(@a,$a): 在数组末尾增加元素.
# pop(@a): 在数组末尾删除元素.

# join('连接符', @a)把数组连接成一个字符串
#@a=('a','b') join(',',@a)='a,b';
#join(',','a','b')='a,b';

# split(/模式/, 分割串, 长度)
# 模式: 缺省为空格, 可省略.
# 分割串: 缺省为$_, 可省略.
# 长度: 可省略, 全部分割.
$s="a,b,c";
@a=split(/,/,$s);
# @a=('a','b','c');
@a=split(/,/,$s,2);
# @a=('a','b,c');

print "\nsplit示例:";
$a='a,b,c';
@b=split(/,/,$a,2);
print "@b\n";

# wantarray(): 当期望返回数组时为真, 返回变量时为假

print "\nwantarray示例:\n";
sub mysub(){print wantarray()?"数组\t":"变量\n";}
@a=mysub;
$a=mysub;

# splice
# @ret = splice(@a, skip, length, @newlist);
# 对@a操作, 跳过skip个元素, 然后开始用@newlist替换length个元素.
# @newlist和length可以不等长, 无论@newlist多长, 他占用(替换)length长的元素位置.
# 当length==0时为插入, splice(@a,-1,0,@n)在末尾追加.
# 当@newlist为空则为删除.
# 当length和@newlist省略时为其后的全部删除.
# splice(@a, 3);

# grep
# @found=grep(/pattern/, @search);
# 对@search的每一个元素搜索匹配模式, 匹配的元素返回到@found数组中.

# map
# map(expr, @list)对@list每个元素进行expr运算, 返回运算后的数组.
# 元素用$_代表. map($_+1,(1,2))-->(2,3)

print "map示例:";
print map($_+1, (1,2));
print "\n";

# 二维数组, 指针实现
# $aoa=[[1,2,3],['a','b','c']];
# 内含2个子数组(1,2,3),('a','b','c').
# 子数组访问: @{$aoa->[0]}
# 子数组元素列表: @{$aoa->[0]}[0,1]
# 元素访问: $aoa->[0][0]

# 由一维数组构成二维数组
@a=(1,2,3);
@b=('a', 'b', 'c');
$aoa=[[@a],[@b]];
print "$aoa->[1][0]\n";

print "二维数组示例: ";
$aoa=[[1,2,3],['a','b','c']];
print "$aoa->[0][0]\n";
print "@{$aoa->[0]}[0,1]\n";
print "@{$aoa->[0]}\n";
print "@$aoa\n";
